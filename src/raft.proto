option (int32_type) = int_t;

package raft;

// - Ordering of Log Entries -
//  
// The default ordering of log entries is descending chronological
// order. The latest log entry (with the highest index) is first
// in the list. 
// 
// The reason for this ordering is to provide efficient usage of the 
// list data structure. 
//
// If the log are ordered in reverse order then the field will be 
// prefixed with [prev]. 
//

// Messages 
// --------

message Message {
    oneof t {
        RequestVoteRequest request_vote_request = 1;
        RequestVoteResponse request_vote_response = 2;
        AppendEntriesRequest append_entries_request = 3;
        AppendEntriesResponse append_entries_response = 4;
    }
}

message RequestVoteRequest {
    required int32 candidate_term           = 1;
    required int32 candidate_id             = 2;
    required int32 candidate_last_log_index = 3; 
    required int32 candidate_last_log_term  = 4;
}

message RequestVoteResponse {
    required int32 voter_id     = 1; 
    required int32 voter_term   = 2; 
    required bool  vote_granted = 3; 
}

message AppendEntriesRequest {
    required int32 leader_term         = 1; 
    required int32 leader_id           = 2; 
    required int32 prev_log_index      = 3; 
    required int32 prev_log_term       = 4; 
    repeated LogEntry rev_log_entries  = 5;
    required int32 leader_commit       = 6; 
}

message AppendEntriesResponse {
    required int32 receiver_id      = 1; 
    required int32 receiver_term    = 2; 
    
    oneof result {
      NoData failure      = 3; 
      SuccessData success = 4; 
    }

    message NoData {}
    message SuccessData {
      required int32 receiver_last_log_index = 1; 
    } 
}

// State
// -----

message State {
  required int32 id           = 1;
  required int32 current_term = 2; 
  repeated LogEntry log       = 3; 
  required int32 commit_index = 4; 
  required int32 last_applied = 5; 

  oneof role {
    LeaderState    leader    = 6;
    CandidateState candidate = 7;
    FollowerState  follower  = 8;
  }

  required Configuration configuration = 9;
}

message LogEntry {
  required int32 index = 1; // starts at 1  
  required int32 term  = 2; // starts at 0
  required bytes data  = 3; 
}

message LeaderState {
  repeated ServerIndex       next_index          = 1;  
  repeated ServerIndex       match_index         = 2;  
  repeated ReceiverHeartbeat receiver_heartbeats = 3;
}

message CandidateState {
  required int32 vote_count         = 1;
  required double election_deadline = 2;
}

message FollowerState {
  optional int32 voted_for = 1; 
  optional int32 current_leader = 2;
}

// This message keeps track of when a heartbeat 
// should be sent to a server by a leader. The 
// leader must ensure that frequent enough heartbeat 
// messages are sent to the receiver in order to prevent
// a new election. 
message ReceiverHeartbeat {
  required int32 server_id           = 1; 
  required float heartbeat_deadline  = 2; 
}

message ServerIndex {
  required int32 server_id        = 1; 
  required int32 server_log_index = 2; 
}

message FollowUpAction {
  message NoData { }
  message WaitForNextRpc {
    enum TimeOutType {
      NEW_LEADER_ELECTION = 1;
      HEARTBEAT           = 2; 
    }
    required double      timeout      = 1;
    required TimeOutType timeout_type = 2;
  }
  oneof t {
    WaitForNextRpc  wait_for_rpc       = 5;
  }
}

message Configuration {
  required int32  nb_of_server           = 1;
  required double election_timeout       = 2;  
  required double election_timeout_range = 3;
    // The election timeout follows a uniform distribution 
    // centered on [election_timeout] and of range
    // [election_timeout_range]. 
  required double hearbeat_timeout       = 4; 
  required int32 max_nb_message          = 5;
}
