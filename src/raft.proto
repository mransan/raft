option (int32_type) = int_t;

package raft;

// OVERVIEW 
// ----------------------------------------------------------------------------
//
// The Raft protocol defines: 
// * 4 messages 
// * 1 server state with 3 mutually exclusive roles. 
// * 2 Timeout events 
//
// The server has always one role assigned and can 
// receive any message at any time. Timeout events 
// as we will see later are specific to roles.
 
// MESSAGES
// ----------------------------------------------------------------------------
//
// Messages define the data exchanged between the servers participating
// in the RAFT protocol. The messages described below don't include 
// the protocol between a client application and the RAFT servers. Those
// messages would be specific to a concrete implementation.
//
// The 4 Raft messages are divided into 2 request/response pairs. 
//
// - Request Vote
//   The [Request Vote] messages are used for leader election. The RAFT 
//   protocol relies on a leader server coordinating the state mofications 
//   and ensuring replication to all the other servers. 
//
// - Append Entries
//   The [Append Entries] messages are used for replication of the 
//   data between the [Leader]] and the [Follower] servers. 
//   Additionally empty [AppendEntriesRequet]s are used for 
//   heartbeat notifications.

// The [Message] type groups together the 4 messages that makes 
// up the RAFT protocol. 
message Message {
    oneof t {
        RequestVoteRequest    request_vote_request    = 1;
        RequestVoteResponse   request_vote_response   = 2;
        AppendEntriesRequest  append_entries_request  = 3;
        AppendEntriesResponse append_entries_response = 4;
    }
}

// [RequestVoteRequest] is sent by a [Candidate] server 
// to ask another server to vote for itself. 
//
// This message is sent when a New Election Timeout and the server
// transitions from [Follower] to [Candidate]. 
// 
// [candidate_term] identifies the election term. The term uniquely
// identifies an election round. 
//
// [candidate_last_log_index] and [candidate_last_log_term] indicates
// the most recent data replicated by the [Candidate ]sender. This 
// information is needed by the receiver of the message to determine if the 
// candidate is up to date. 
// 
message RequestVoteRequest {
    required int32 candidate_term           = 1;
    required int32 candidate_id             = 2;
    required int32 candidate_last_log_index = 3; 
    required int32 candidate_last_log_term  = 4;
}

// [RequestVoteResponse] is the message expected to be sent by a server 
// in reply to a [RequestVoteRequest]. 
// 
// In short it indicates whether or not the server has granted 
// its vote for this election.
//
message RequestVoteResponse {
    required int32 voter_id     = 1; 
    required int32 voter_term   = 2; 
    required bool  vote_granted = 3; 
}

// [AppendEntriesRequest] is send by a [Leader] server to 
// replicate data to the other servers. 
// 
// While data replication is the primary purpose of this message
// it also has additional functionality. 
//
// Establishing Leadersip:
//   Because only a [Leader] can send such a message, this message
//   type is also an indication to other servers that the sender
//   is the current [Leader]. Therefore a freshly elected server (ie which 
//   transitioned from Candidate to Leader after receiving a majority
//   of vote) will immediately send an [AppendEntriesRequest] to establish
//   its leadership to the other servers. 
// 
// Heartbeat:
//   In order for a leader to maintain its [Leader] role it must 
//   continuously remind other servers of its current leadership. In fact
//   if the [Leader] fails to do so, another server will eventually believe 
//   that the Leader is no longer assuming its role. That server will
//   consequently initiate a new election among the servers.
//   The [Leader] is therefore sending empty [AppendEntriesRequest] at regular 
//   time intervals to perpetuate its [Leader] role.
//
// [leader_term]/[leader_id] identifies the server. The [leader_term] is 
// also used by the receiver of the message to either be aware of a new term or 
// detect that Leader is from an older term and therefore reject the request. 
// 
// [prev_log_index]/[prev_log_term] indicates the [Leader] belief of what was 
// the last replicated data on the receiver. This information is crucial for 
// synching together a [Leader] and a [Follower]. 
// In particular right after transitioning to [Leader], the server 
// can only guess the replicated state on the other servers. 
// In fact it first assumes that all other servers have replicated the exact
// same data as it did. This is most likely incorrect and the first interaction
// of a [Leader] and its [Followers] is to rectify this.
//
// [rev_log_entries] contains the data to be replicated. It's in reverse
// order for performance reason only. (See note on Log Entries ordering). 
// 
// [leader_commit] indicates the latest data replicated by a majority of 
// servers. This information is helpful for the receiver since it can now
// assume that any data up to that index will be persisted forever. Note
// that any data/log which have a later index than the commit index might 
// later be invalidated. 
//
message AppendEntriesRequest {
    required int32 leader_term         = 1; 
    required int32 leader_id           = 2; 
    required int32 prev_log_index      = 3; 
    required int32 prev_log_term       = 4; 
    repeated LogEntry rev_log_entries  = 5;
    required int32 leader_commit       = 6; 
}

// [AppendEntriesResponse] is the message send by a server in response
// a previously received AppendEntriesRequest. 
// 
// Besides the id and term of the server sending this message, the main
// content of the message the indication whether or not the append entry
// was successfull. 
//
// In the case it was successfull then the server sends its 
// [receiver_last_log_index] so that the [Leader] can update its own 
// belief of what the last replicated data on that server. 
//
// An append entry can fail for 2 reasons:
//
// - Outdated Leader Term. 
//   It is possible that a [Leader] has already been replaced by 
//   another server during a new election. In such a case the [leader_term]
//   will be less than the receiver_term. Since the response 
//   contains the [receiver_term], this outdated [Leader] will
//   realize it should no longer assume suc a role and will transition to 
//   becoming a [Follower] in the current term. 
// 
// - Invalid [prev_log_index]/[prev_log_index]
//   As previously mentioned in the [AppendEntriesRequest] it is possible
//   that the [Leader] belief of the latest replicated data on the server
//   is incorrect. 
// 
message AppendEntriesResponse {
    required int32 receiver_id      = 1; 
    required int32 receiver_term    = 2; 
    
    oneof result {
      NoData failure      = 3; 
      SuccessData success = 4; 
    }

    message NoData {}
    message SuccessData {
      required int32 receiver_last_log_index = 1; 
    } 
}

// STATE
// ----------------------------------------------------------------------------
// 
// In this section we will define the [State] of the servers. The [State] is 
// composed into 2 parts
//
// - Common data
//   This data is common to all the servers no matter what role they have.
//
// - Role based data
//   Data specific to a particular role

// State structure
//
// [id] 
//   Id the logical id of the server. Its range is `[0; nb_of_server[`. 
//     
// [current_term]
//   TODO.
// 
// [log] & [log_size]
//   Data to be replicated by the RAFT consensus.
//   [log_size] is simply an optimization, since [log] is represented
//   as an OCaml list, computing the length is a linear operation.
//
// [commit_index]
//   It's the latest log index which has been successfully replicated 
//   on a majority of servers. 
// 
// [configuration] 
//   Cluster configuration (number of server and various timeout 
//   values). 
// 
// [role] 
//   The current role of the server. [oneof] guarantees that 
//   the server can only be in one role at a time.
//
message State {
  required int32 id           = 1;
  required int32 current_term = 2; 
  repeated LogEntry log       = 3; 
  required int32 log_size     = 10;
  required int32 commit_index = 4; 

  oneof role {
    LeaderState    leader    = 6;
    CandidateState candidate = 7;
    FollowerState  follower  = 8;
  }

  required Configuration configuration = 9;
}

// [LogEntry] 
// 
// RAFT protocol ensure consensus on the execution of a 
// state machine. In other word each RAFT server must eventually
// execute the exact same state machine instructions hence leading to the
// same state.
//
// Each instruction of the state machine is wrapped into a [LogEntry]. 
// 
// [data] 
//   Placeholder for the application state machine instruction. 
//
// [index]
//   Instruction index. Each new instruction index increment by 1 
//   the previous instruction index. 
//
// [term]
//   During which term the log entry was inserted into the state [Log].
//
message LogEntry {
  required int32 index = 1; // starts at 1  
  required int32 term  = 2; // starts at 0
  required bytes data  = 3; 
}

// [LeaderState]
//
// When a server is a [Leader] it must keep tracks of several 
// information in order to do its job. 
//
// [next_index]
//   Which [LogEntry] should be sent next to a particular 
//   server. This information is used when the [Leader] computes 
//   the [AppendEntriesRequest] for a [Follower]: it 
//   will send all the [LogEntry] with index >= to that index. 
// 
// [match_index] 
//   The index of the last known replicated [LogEntry]. This 
//   information is used by the [Leader] to know if a particular
//   [LogEntry] has been replicated on a majority of server and 
//   can therefore be commited.
//
// [receiver_heartbeats]
//   In order to maintain its leadership the [Leader] must 
//   regularly send [AppendEntriesRequest] to all the [Follower]s.
//   [receiver_heartbeats] keeps track of when should the next 
//   heartbeat message be sent.
//  
message LeaderState {
  repeated ServerIndex       next_index          = 1;  
  repeated ServerIndex       match_index         = 2;  
  repeated ReceiverHeartbeat receiver_heartbeats = 3;
}

// [CandidateState]
//
// When a server is a [Candidate] it must keep track of its 
// [vote_count] so that when it reaches a majority of votes it 
// becomes a leader. 
// 
// Additionally each election can only last for so long (based 
// on the configuration) and therefore the [Candidate] must keep
// track of when the election should end [election_deadline]. 
//
// It's important to note that a [Candidate] will only start a 
// new election after the [election_deadline]. Event if it 
// receives a majority of negative responses it has to wait until then.
// This gives the chance to another server to create a new election.
//
message CandidateState {
  required int32 vote_count         = 1;
  required double election_deadline = 2;
}

// [FollowerState]
//
// When a server is a [Follower] it first keeps track of its [Leader].
// This information is optional because during an election there are no
// [Leader]s. The [Follower] keeps track of this information so that 
// if a client applcation is sending a request to it, it can redirect 
// the client to the appropriate [Leader] server.
//
// The [Follower] is also keeping track of which [Candidate] it voted
// for during its current term. This is to ensure that a [Follower] can 
// only vote once.
// 
// Finally the [Follower] also sets an [election_deadline]. If it has 
// not receive any [AppendEntriesRequest] from a valid [Leader] until
// [election_deadline], it will then become a [Candidate] for the next 
// term. 
// We can see now how crucial it is for the [Leader] to send regular
// heartbeat messages to the [Follower]. Each time an [AppendEntriesRequest]
// is received by the [Follower] it will reset its [election_timeout]. 
//
message FollowerState {
  optional int32 voted_for          = 1; 
  optional int32 current_leader     = 2;
  required double election_deadline = 3;
}

message ReceiverHeartbeat {
  required int32 server_id           = 1; 
  required float heartbeat_deadline  = 2; 
}

message ServerIndex {
  required int32 server_id        = 1; 
  required int32 server_log_index = 2; 
}

message Configuration {
  required int32  nb_of_server           = 1;
  required double election_timeout       = 2;  
  required double election_timeout_range = 3;
    // The election timeout follows a uniform distribution 
    // centered on [election_timeout] and of range
    // [election_timeout_range]. 
  required double hearbeat_timeout       = 4; 
  required int32 max_nb_logs_per_message = 5;
}

// TIMEOUT EVENTS
// ----------------------------------------------------------------------------
// 

message TimeoutEvent {
  enum TimeOutType {
    NEW_LEADER_ELECTION = 1;
    HEARTBEAT           = 2; 
  }
  required double      timeout      = 1;
  required TimeOutType timeout_type = 2;
}


// Notes 
// ---------------

// - Ordering of Log Entries -
//  
// The default ordering of log entries is descending chronological
// order. The latest log entry (with the highest index) is first
// in the list. 
// 
// The reason for this ordering is to provide efficient usage of the 
// list data structure. 
//
// If the log are ordered in reverse order then the field will be 
// prefixed with [prev]. 
//
